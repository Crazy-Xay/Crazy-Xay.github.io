{"meta":{"title":"Tyl丶的博客","subtitle":"记录我的生活","description":"你认真的说你喜欢白山茶❀","author":"汪剑平","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"HUD1010Tempter of the Bone","date":"2021-01-25T14:56:12.333Z","updated":"2021-01-26T11:56:02.278Z","comments":true,"path":"2021/01/25/HUD1010Tempter of the Bone/","link":"","permalink":"http://example.com/2021/01/25/HUD1010Tempter%20of%20the%20Bone/","excerpt":"","text":"寒假的第一次周练总的来说难但是也有些是简单的比较常规的，感觉到了我对动态规划和搜索的理解还不是很清晰，无法灵活的运用上来，也就是看到题目不知道从何入手，看来要多刷点动态规划和搜索的题目来强化自己的理解，写了4题的我就直接下了 HUD1010Tempter of the Bone一看到题目的输入然后翻译了一下题目的意思我直接就想到了这是搜索的题目，而且和我做过的题目相当类似，但是我按照我的方法做好多次才做出来，不知道是不是字符串的缘故 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define xa x+a[i]#define yb y+b[i]using namespace std;char g[8][8];int a[]=&#123;0,0,1,-1&#125;;int b[]=&#123;-1,1,0,0&#125;;int n,m,t,step,remain,destx,desty;bool flag;void dfs(int x,int y,int tc)&#123; if(tc==t&amp;&amp;x==destx&amp;&amp;y==desty)&#123; flag=true; return ; &#125; int v=t-tc-abs(destx-x)-abs(desty-y); if((abs(destx-x)+abs(desty-y))%2!=(t-tc)%2) return ; for(int i=0;i&lt;4;i++)&#123; if(xa&gt;=0&amp;&amp;xa&lt;n&amp;&amp;yb&gt;=0&amp;&amp;yb&lt;m&amp;&amp;g[xa][yb]!=&#x27;X&#x27;)&#123; g[xa][yb]=&#x27;X&#x27;; dfs(xa,yb,tc+1); g[xa][yb]=&#x27;.&#x27;; &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;t)&#123; if(n==0&amp;&amp;m==0&amp;&amp;t==0) break; step=remain=0; flag=false; int icur,jcur; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;g[i][j]; if(g[i][j]==&#x27;S&#x27;) icur=i,jcur=j; else if(g[i][j]==&#x27;D&#x27;) remain++,destx=i,desty=j; else if(g[i][j]==&#x27;.&#x27;) remain++; &#125; &#125; g[icur][jcur]=&#x27;X&#x27;; if(remain&gt;=t) dfs(icur,jcur,0); if(flag) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"日记","slug":"2021-1-23-日记1","date":"2021-01-21T16:00:00.000Z","updated":"2021-01-31T13:31:18.680Z","comments":true,"path":"2021/01/22/2021-1-23-日记1/","link":"","permalink":"http://example.com/2021/01/22/2021-1-23-%E6%97%A5%E8%AE%B01/","excerpt":"他们就是我前进的动力❀","text":"他们就是我前进的动力❀ 作息时间表 数据结构 刷题+网安 跑步+博客 2020-1-31今天不想写日记 2020-1-30 继续做了一题就做不下去了，感觉自己对于深度搜索和广度搜索还是不懂，还有动态规划，要继续加强 下午去打球了 晚上也没做事，今天就当放假一天了吧~~~ 2020-1-29 今天起来就是十一点多了，然后学了2个小时，到了差不多2点我就去睡觉了，然后下午朋友叫我去打球一直到晚上9点才回家 回家之后就是紧张刺激的大乱斗了，男枪是真滴强啊 ACS周测做到4点钟，我来写了这篇日记，cleangd一下准备睡觉了，今天大概只学了6个小时，明天继续加油！！！ 2020-1-28 上午睡到11点起来我服了，后面吃完饭也没事干玩了一会 下午一直在看数据结构的视频断断续续做了一些前面的题目，发现蓝桥杯里的高精度的那些不会做，蓝桥杯还是有难题的，要重视起来 晚上把数据结构干完了，还是要多看几遍，还没搞清楚c++的对象和::含义还有视屏里头的template ‘‘是什么意思，好难办，而且计算复杂度还要再去看看 2020-1-27 上午写了会题解，肚子不太舒服 晚上出去上网了啥也没干今天就休息一天吧明天继续 2020-1-26 今天又是熬夜的一天到底自己的自制力为啥这样！！！ 开始进行linux的学习了，今天刚刚看到ls命令明天加油 博客第一题搞了我好久好久但是我今天终于可以自己完整的写出来了，我好开心，明天继续后面的题目，争取写多一些，来丰富我的博客 刚刚更换完notepad++来进行c++的编译和运行不得不说notepad++的界面以及书写真的好看又舒服，不过就是运行的时候有点麻烦必须要先保存之后在进行编译运行不然的话就是原先的代码继续运行😄 2020-1-25 今天上午把三个多小时的树蕨结构绪论给看完了，但是课后作业错了一个，对于时间复杂度以及时间复杂度的例子，我对视频里的最长公共子序列不太明白，不知道他那张表格是怎样画出来的，明天接着来看看 准备了好久准备写的题解报告，但是第一题我自己又去做一遍却又不对了耗了我好久时间但是我明明就觉得我的代码没问题，但是就是错了，今天大概只有八个小时，明天继续加油 多说一句ywq真的好强啊！！！向他学习 2021-1-24 为什么今天上午一起床就又停电了啊啊啊啊啊啊啊啊？？？！ 今天开始早睡早起,彻底改变自己的习惯,下午回二中打了一下午的球,腰真的好痛,看来有失必有得是真的,现在就在这篇日记里规划下自己的下星期吧 前一天规划好第二天要做的事 完成当日的新阶段学习 上午就看书把 上午起来看书一样的操作系统 上午一样看书 看书看书看书 做题目做的有点晚了就晚点起来吧 作息调整 回顾之前的内容 数据结构向量内容 数据结构向量 数据结构视频复习回顾 蓝桥杯+补题+写题解 看视频+写博客加深记忆 博客 写题解+网安 晚上写博客+看视频 晚上写博客+看视频 写博客+Linux Linux专场 Linux666 linux 2021-1-23 今天上午停电,来电之后就开始做ACS的周测,感觉到自己对于dp还有dfs的理解以及运用还是有待加强,明天开始我就要改变我的作息习惯了 搁置了一天的网安学习,在24号2点来看了两节止损,希望明天和后天把汇编语言直接解决了,然后直接进去kali还有二进制安全的学习 还有就是我觉得我的男枪水平有点提高？好久没去网吧打游戏,感觉还挺舒服的,哈哈 2021-1-22 今天租了9个月的服务器,还注册了域名,然后博客也再搭了一个,准备以后拿这个来写我的日记,在那边更新我的学习,主要是那个主题太好看了23333 ACS今天的广度优先搜索看的我一脸懵,视频里调用栈的方式我没看明白,明天还有周测不知道可不可以拿到一个好的名次😰 汇编语言今天都没看,我也不知道乐子咋那么快就学完了,可能是我看的慢,不过我已经到第十章了,继续加油！","categories":[],"tags":[{"name":"-Daile Life","slug":"Daile-Life","permalink":"http://example.com/tags/Daile-Life/"}]},{"title":"Dfs搜索函数学习","slug":"2021-1-20-Dfs搜索函数学习","date":"2021-01-19T16:00:00.000Z","updated":"2021-01-21T10:09:57.505Z","comments":true,"path":"2021/01/20/2021-1-20-Dfs搜索函数学习/","link":"","permalink":"http://example.com/2021/01/20/2021-1-20-Dfs%E6%90%9C%E7%B4%A2%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1.我对Dfs的理解12345/* 1.dfs的起点 2.某一点dfs的下一步以及进入下一步要满足的条件,还有走过路径的标记,最后跳出时要将标记还原 3.和递归一样要有一个终点,也就是出口让dfs跳出*/ 下面我来写一个指导的模板 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int cnt=0;int vis [25][25];void dfs(int i,int j)&#123; if(vis[i][j])&#123; return ; &#125; vis[i][j]=1; //走过的地方打上标记 cnt++； if(!vis[i+1][j]) dfs(i+1,j); if(!vis[i-1][j]) dfs(i-1,j); //这里就是进入下一个节点的条件 if(!vis[i][j+1]) dfs(i,j+1); if(!vis[i][j-1]) dfs(i,j-1); vis[i][j]=0; //dfs过后让原来打上的标记擦除&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); //省略了二维数组的写法 printf(&quot;%d\\n&quot;,cnt); return 0;&#125; 2.","categories":[],"tags":[{"name":"-Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"}]},{"title":"Web网络安全学习","slug":"2021-1-7-Web网络安全学习","date":"2021-01-06T16:00:00.000Z","updated":"2021-01-11T11:33:44.355Z","comments":true,"path":"2021/01/07/2021-1-7-Web网络安全学习/","link":"","permalink":"http://example.com/2021/01/07/2021-1-7-Web%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/","excerpt":"我心如雷🌩","text":"我心如雷🌩 1.IP地址详解 子网掩码:1.255.0.0.0 2.255.255.0.0 3.255.255.255.0 回环地址:127.0.0.1 用以测试自身网卡损坏 如:192.168.1.1 子网掩码为255.255.0.0 则该网段为192.168网段 主机位是1.1 此子网掩码有65534种 网关:一个网络的出口,Gateway=GW 网关一般在路由器上 同网段中通信不需要网关直接使用交换机 PC向外发包过程： 首先判断目标IP地址与自己是否在同一网段 如果在同一网段，则直接发出去，而不找网关 如果不在同一网段，则直接发包给网关 DNS: Domain Name Service 域名服务1.如何查看IP地址 首先：开始–运行–输入cmd–进入命令窗口或者win+r打开运行窗口 12ipconfig #查看IP地址基本信息ipconfig &#x2F;all #查看IP地址详细信息 2.测试网络连通性 12345ping 目标IP地址 #测试网络连通性，有去有回即为可以成功通信ping -t 目标IP地址 #一直pingping -n 数字 目标IP地址 #修改ping包的数量ping -l 数字 目标IP地址 #修改ping包的大小注：如果ping不通，可能对方不在线，或者对方开着防火墙 3.手动解析域名 nslookup 目标网址或者目标IP地址 #手动解析域名的IP地址 2.1）NTFS安全权限 通过设置NTFS权限，实现不同的用户访问不同的权限 分配了正确的访问权限后，用户才能访问其资源 设置权限防止资源被篡改、删除 2.2）文件系统概述文件系统即在外部存储设备上组织文件的方法–某一分区的存储格式 格式化就是定制文件 常用的文件系统： FAT Windows NTFS Windows EXT Linux常见 3.DHCP部署与安全–Dynamic Host Configure Protocol DHCP作用：自动分配IP地址 DHCP相关概念：地址池/作用域：（IP、子网掩码、网关、DNS、租期），DHCP协议端口事UDP 67/68 DHCP优点：减少工作量、避免IP冲突、提高地址利用率 DHCP原理：也称为DHCP租约过程，分为4个步骤 1）发送DHCP Discovery广播包：客户机广播请求IP地址（包含客户机的MAC地址） 2）服务器响应DHCP Offer广播包：服务器响应提供的IP地址（但无子网掩码、网关等参数） 3）响应DHCP Request广播包：客户机选择IP（也可认为确认使用哪个IP） 4）发送DHCP ACK广播包：服务器确定了租约，并提供网卡详细参数IP、掩码、网关、DNS、租期等 DHCP续约：当50%过后，客户机会再次发送DHCP Request包，进行续约，如果服务器无响应，则继续使用并在87.5%再次发送DHCP Request包，进行续约，如仍然无响应，并释放IP地址，及重新发送DHCP Request广播包来获取IP地址，当无任何服务器响应时，自动给自己分配一个169.254.X.X/16，属于全球统一无效地址，用于临时内网通信！ 部署DHCP服务器 1）IP地址固定（服务器必须固定IP地址） 2）安装DHCP服务插件 3）新建作用域及作用域选项 4）激活 5）客户及验证： 12ipconfig &#x2F;release 释放IP(取消租约，或者改为手动配置IP，也可以释放租约)ipconfig &#x2F;renew 重新获取IP(有IP时发送Request续约无IP时发送Discovery重新获取) 地址保留：针对指定的MAC地址，固定动态分配IP地址 选项优先级：作用域选项&gt;服务器选项 //当服务器上有多个作用域时，可以在服务器选项上设置DNS服务器 DHCP备份 DHCP攻机与防御： 1）攻击DHCP服务器：频繁的发送伪装的DHCP请求，直到将DHCP地址池资源耗尽 ​ 防御：在交换机上（管理型）的端口做动态MAC地址绑定 2）伪装DHCP服务器攻击客户机：hacker通过将自己部署为DHCP服务器,为客户机提供非法IP地址 ​ 防御：在交换机上，除合法的DHCP服务器所在接口外，全部设置为禁止发送DHCP Offer包 常见小问题 4.DNS部署与安全 DNS：Domain Name Service（域名服务）作用：为客户及提供域名解析服务 域名组成： 1）域名组成概述： 如”www.sina.com.cn&quot;是一个域名，从严格意义上讲，&quot;sina.com.cn&quot;才被称为域名(全球唯一)，而&quot;www&quot;是主机名。 “主机名.域名”称为完全限定域名(FQDN)，一个域名下可以有多个主机，域名全球唯一，那么”主机名.域名”肯定也是全球唯一的。 以”sina.com.cn”域名为例，一般管理员在命名其主机的时候会根据其主机的功能而命名，比如网站的是www，博客的是blog，论坛的是bbs，那么对应的FQDN为www.sina.com.cn，blog.sina.com.cn，bbs.sina.com.cn。这么多个FQDN，然而我们只需要申请一个域名即&quot;sina.com.cn&quot;即可。 这篇文章就到这里吧","categories":[],"tags":[{"name":"-Network Security","slug":"Network-Security","permalink":"http://example.com/tags/Network-Security/"}]},{"title":"2020寒假集训四(GCD)--NEFU","slug":"2021-1-4-2020寒假集训四(GCD)","date":"2021-01-03T16:00:00.000Z","updated":"2021-01-06T13:37:06.013Z","comments":true,"path":"2021/01/04/2021-1-4-2020寒假集训四(GCD)/","link":"","permalink":"http://example.com/2021/01/04/2021-1-4-2020%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD%E5%9B%9B(GCD)/","excerpt":"你认真的说你喜欢白山茶❀","text":"你认真的说你喜欢白山茶❀ 寒假来学习数论,在很多地方都出现了 辗转相除法1234int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125; 1.最大公约数和最小公倍数123456789101112131415#include&lt;stdio.h&gt;int gcd(int a,int b) //辗转相除法&#123; return b?gcd(b,a%b):a;&#125;int main()&#123; int a,b; while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b)) &#123; printf(&quot;%d %d\\n&quot;,gcd(a,b),a*b/gcd(a,b)); &#125; return 0;&#125; 2. 又见GCD123456789101112131415161718192021#include&lt;stdio.h&gt;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;int main()&#123; int a,b,c; while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b)) &#123; c=2*b; //因为b是较小数,所以c最小为2*b然后向上依次加b while(c)&#123; if(gcd(a,c)==b) break; c+=b; //c的步长 &#125; printf(&quot;%d\\n&quot;,c); &#125; return 0;&#125; 3.多个数的最大公约数12345678910111213141516171819#include&lt;stdio.h&gt;typedef long long ll;ll gcd(ll a,ll b)&#123; return b?gcd(b,a%b):a;&#125;int main()&#123; ll a[11],n; while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=1;i&lt;=n-1;i++) a[i+1]=gcd(a[i],a[i+1]); //此循环中将前两个数的最小共约数给后一个数向上推 printf(&quot;%lld\\n&quot;,a[n]); &#125; return 0;&#125; 4.多个数的最小公倍数12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;typedef long long ll;ll a[51]=&#123;0&#125;;ll gcd(ll a,ll b)&#123; return b?gcd(b,a%b):a;&#125;ll lcm(ll a,ll b)&#123; return (a/gcd(a,b))*b;&#125;ll solve(ll a[],ll n)&#123; ll ans; ans=lcm(a[0],a[1]); for(int i=2;i&lt;n;i++) ans=lcm(ans,a[i]); return ans;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0;i&lt;n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); ll ans=solve(a,n); printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125; 5.LCM&amp;GCD123456#include&lt;stdio.h&gt;int main()&#123; &#125; 6.人见人爱gcd1234567891011121314151617181920#include&lt;stdio.h&gt;typedef long long ll;ll gcd(ll a,ll b)&#123; return b?gcd(b,a%b):a;&#125;int main()&#123; ll t,a,b; while(~scanf(&quot;%lld&quot;,&amp;t)&amp;&amp;t) &#123; while(t--)&#123; scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b); ll ans=gcd(a,b); printf(&quot;%lld\\n&quot;,a*a-2*ans*b); //a*a=x^2+y*2+2*x*y|2*ans*b=2*x*y &#125; &#125; return 0;&#125; 8.快速幂取模123456789101112131415161718192021222324#include&lt;stdio.h&gt;typedef long long ll;ll mode(ll g,ll n,ll mod)&#123; ll ans=1; while(n) &#123; if(n&amp;1) ans=ans*g%mod; g=g*g%mod; n&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; ll a,b,c; while(~scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c)) &#123; printf(&quot;%lld\\n&quot;,mode(a,b,c)); &#125; return 0;&#125; 9.库特的数学题1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;typedef long long ll;const ll mod=1e9+7;ll mode(ll a,ll b)&#123; ll ans=1; while(b)&#123; if(b%2)&#123; ans=ans*a%mod; b--; &#125; b/=2; a=a*a%mod; &#125; return ans;&#125;int main()&#123; ll n,m; while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; m=mode(3,n); m*=2; m%=mod; printf(&quot;%lld\\n&quot;,m); &#125; return 0;&#125; 感谢NEFUOJ","categories":[],"tags":[{"name":"-Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"}]},{"title":"动态规划","slug":"2021-1-3-动态规划","date":"2021-01-02T16:00:00.000Z","updated":"2021-01-18T16:56:56.334Z","comments":true,"path":"2021/01/03/2021-1-3-动态规划/","link":"","permalink":"http://example.com/2021/01/03/2021-1-3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"你熄灭了烟说起从前👋","text":"你熄灭了烟说起从前👋 动态规划理解 大概知道的动规的思想：状态转移式+保存 1.三角形最大和(课件最后一种写法将二维转化为一维)1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#define MAX 101int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int dp[MAX][MAX]=&#123;0&#125;; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; scanf(&quot;%d&quot;,&amp;dp[i][j]); &#125; &#125; int *maxSum; maxSum=dp[n]; for(int i=n-1;i&gt;=1;i--)&#123; for(int j=1;j&lt;=n;j++)&#123; maxSum[j]=max(maxSum[j],maxSum[j+1])+dp[i][j]; &#125; &#125; printf(&quot;%d\\n&quot;,maxSum[1]); return 0;&#125; 2.最长上升子序列12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int a[1010];int maxlen[1010];int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); maxlen[i]=1; //每一种情况默认加上本身的情况 &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;i;j++)&#123; if(a[i]&gt;a[j]) maxlen[i]=max(maxlen[i],maxlen[j]+1); //如果条件成立就是j的情况+1 &#125; &#125; int maxn=-1; for(int i=1;i&lt;=n;i++) if(maxlen[i]&gt;maxn) maxn=maxlen[i]; printf(&quot;%d\\n&quot;,maxn); return 0;&#125; 3.最佳加法表达式1","categories":[],"tags":[{"name":"-Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"}]},{"title":"C语言学习笔记","slug":"2020-12-26-C语言学习笔记","date":"2020-12-25T16:00:00.000Z","updated":"2021-01-17T14:38:23.325Z","comments":true,"path":"2020/12/26/2020-12-26-C语言学习笔记/","link":"","permalink":"http://example.com/2020/12/26/2020-12-26-C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"🤡","text":"🤡 1.单链表的建立函数(“creatlink”)1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct node&#123; int data; struct node *next;&#125;;typedef struct node linknode;typedef linknode *linklist;linklist creatlink()&#123; linklist head,tail,q; int x; head=tail=NULL; printf(&quot;请输入整数序列（以0为结束）:\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x!=0) &#123; q=(linklist)malloc(sizeof(linknode)); q-&gt;data=x; if(head==NULL) head=tail=q; else&#123; tail-&gt;next=q; tail=q; &#125; scanf(&quot;%d&quot;,&amp;x); &#125; if(tail!=NULL) tail-&gt;next=NULL; return head;&#125; 2.单链表的输出函数(void print(linklist head))1234567891011121314#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void print(linklist head)&#123; linklist p=head; printf(&quot;List:\\n&quot;); while(p!=NULL) &#123; printf(&quot;%5d&quot;,p-&gt;data); p=p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125; 3.单链表的查找函数(“linklist searchlink”)12345678910#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;linklist searchlink(linklist head,int x)&#123; linklist p=head; while(p!=NULL&amp;&amp;p-&gt;data!=x) p=p-&gt;next; return p;&#125; Linklist All12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct node&#123; int data; struct node *next;&#125;;typedef struct node linknode;typedef linknode* linklist;linklist creatlink()&#123; linklist head,tail,q; int x; head=tail=NULL; printf(&quot;请输入整数序列(以0为结束):\\n&quot;); scanf(&quot;%d&quot;,&amp;x); while(x!=0) &#123; q=(linklist)malloc(sizeof(linknode)); q-&gt;data=x; if(head==NULL) head=tail=q; else&#123; tail-&gt;next=q; tail=q; &#125; scanf(&quot;%d&quot;,&amp;x); &#125; if(tail!=NULL) tail-&gt;next=NULL; return head;&#125;void print(linklist head)&#123; linklist p=head; printf(&quot;List:\\n&quot;); while(p!=NULL) &#123; printf(&quot;%5d&quot;,p-&gt;data); p=p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;linklist searchlink(linklist head,int x)&#123; linklist p=head; while(p!=NULL&amp;&amp;p-&gt;data!=x) p=p-&gt;next; return p;&#125;int main()&#123; int x; linklist head,p; head=creatlink(); print(head); printf(&quot;请输入要查找的结点值:&quot;); scanf(&quot;%d&quot;,&amp;x); p=searchlink(head,x); if(p!=NULL) printf(&quot;查找成功！\\n&quot;); else printf(&quot;查找失败！\\n&quot;); return 0;&#125; Last.大一上学期C语言考试最后一题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define MAXNAMELEN 30#define MAXTELLEN 12 #define MAXADDRESSLEN 100struct telephone_list&#123; char name[MAXNAMELEN]; char tel[MAXTELLEN]; char address[MAXADDRESSLEN]; struct telephone_list *next;&#125;;typedef struct telephone_list list;typedef list *linklist;linklist creatlink()&#123; linklist head,tail,q; head=tail=NULL; char a[30],b[13],c[101]; for(int i=0;i&lt;2;i++)&#123; gets(a); gets(b); gets(c); q=(linklist)malloc(sizeof(list)); strcpy(q-&gt;name,a); strcpy(q-&gt;tel,b); strcpy(q-&gt;address,c); if(head==NULL) head=tail=q; else&#123; tail-&gt;next=q; tail=q; &#125; &#125; if(tail!=NULL) tail-&gt;next=NULL; return head;&#125;linklist searchlink(linklist head,char d[])&#123; linklist p=head; while(p!=NULL&amp;&amp;(strcmp(p-&gt;name,d))!=0)&#123; p=p-&gt;next; &#125; return p;&#125;linklist dellink(linklist head,char e[])&#123; linklist pre=NULL,p=head; while(p!=NULL&amp;&amp;(strcmp(p-&gt;name,e)!=0))&#123; pre=p; p=p-&gt;next; &#125; if(p)&#123; if(pre==NULL) head=head-&gt;next; else pre-&gt;next=p-&gt;next; free(p); &#125; return head;&#125;void print(linklist head)&#123; linklist p=head; while(p!=NULL)&#123; printf(&quot;%s %s %s\\n&quot;,p-&gt;name,p-&gt;tel,p-&gt;address); p=p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; linklist head,p; head=creatlink(); char d[31],e[31]; gets(d); p=searchlink(head,d); print(head); if(p!=NULL)&#123; printf(&quot;查找成功!\\n&quot;); printf(&quot;%s %s %s\\n&quot;,p-&gt;name,p-&gt;tel,p-&gt;address); &#125; else printf(&quot;查找失败!\\n&quot;); gets(e); head=dellink(head,e); print(head); return 0;&#125;","categories":[],"tags":[{"name":"-Course Learning","slug":"Course-Learning","permalink":"http://example.com/tags/Course-Learning/"}]},{"title":"圣诞节月赛","slug":"2020-12-25-圣诞节月赛","date":"2020-12-24T16:00:00.000Z","updated":"2020-12-29T04:29:11.614Z","comments":true,"path":"2020/12/25/2020-12-25-圣诞节月赛/","link":"","permalink":"http://example.com/2020/12/25/2020-12-25-%E5%9C%A3%E8%AF%9E%E8%8A%82%E6%9C%88%E8%B5%9B/","excerpt":"为啥和新风杯一样的结果啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊","text":"为啥和新风杯一样的结果啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 A.分糖果(HDU-2034集合的减法A-B)(HDU-2034)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;void sort(int a[],int n)&#123; int t; for(int i=0;i&lt;n-1;i++) &#123; for(int j=i+1;j&lt;n;j++) //题目要求按从小到大顺序输出 &#123; if(a[i]&gt;a[j]) &#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; &#125;&#125;int main()&#123; int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; if(n==0&amp;&amp;m==0) return 0; int a[101]=&#123;0&#125;,b[101]=&#123;0&#125;,c[101]=&#123;0&#125;,k=0; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=0;i&lt;n;i++) &#123; int flag1=0; for(int j=0;j&lt;m;j++) if(a[i]==b[j]) flag1++; if(flag1==0) &#123; c[k]=a[i]; k++; &#125; &#125; if(k==0) printf(&quot;NULL\\n&quot;); else&#123; sort(c,k); for(int i=0;i&lt;k;i++) printf(&quot;%d &quot;,c[i]); printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125; B.简单深搜dp没做来啊啊啊啊啊啊啊啊急死我了(HDU-)123456#include&lt;stdio.h&gt;int dp[1010],map[1010];int main()&#123; &#125; C.用一种特殊情况即可12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=k;i++) printf(&quot;a&quot;); char ch=&#x27;a&#x27;; for(int i=1;i&lt;=n-k;i++) printf(&quot;%c&quot;,ch+i%3); printf(&quot;\\n&quot;); &#125; return 0;&#125; D.归并排序(求逆序对个数)(POJ-)12#include&lt;stdio.h&gt; E.求唯一个数123456789101112//一般做法#include&lt;stdio.h&gt;const int N=1000010;int d[N];int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; &#125;&#125; 123456789101112131415161718//异或做法#include&lt;stdio.h&gt;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; int max=0,x; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;x); max^=x; &#125; printf(&quot;%d\\n&quot;,max); &#125; return 0;&#125; F.贪心123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;typedef long long ll;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); ll a,b,x,y,n; ll aa,bb,ans; for(;t&gt;0;t--) &#123; scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;x,&amp;y,&amp;n); aa=a-n; if(aa&lt;x) aa=x; bb=b-(n-(a-aa)); if(bb&lt;y) bb=y; ans=aa*bb; bb=b-n; if(bb&lt;y) bb=y; aa=a-(n-(b-bb)); if(aa&lt;x) aa=x; if(ans&gt;aa*bb) ans=aa*bb; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125; G.Google的恐龙123456789101112#include&lt;stdio.h&gt;typedef long long ll;int main()&#123; ll n,m; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); ll x; for(ll i=0;i&lt;m;i++) scanf(&quot;%lld&quot;,&amp;x); printf(&quot;%.6lf\\n&quot;,(n-1)*n/2.0/m); return 0;&#125;","categories":[],"tags":[{"name":"-Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"}]},{"title":"东北林业大学第15届校赛（大一组）赛后题解与思考","slug":"2020-12-22-东北林业大学第15届校赛（大一组）赛后思考","date":"2020-12-21T16:00:00.000Z","updated":"2020-12-23T13:05:04.747Z","comments":true,"path":"2020/12/22/2020-12-22-东北林业大学第15届校赛（大一组）赛后思考/","link":"","permalink":"http://example.com/2020/12/22/2020-12-22-%E4%B8%9C%E5%8C%97%E6%9E%97%E4%B8%9A%E5%A4%A7%E5%AD%A6%E7%AC%AC15%E5%B1%8A%E6%A0%A1%E8%B5%9B%EF%BC%88%E5%A4%A7%E4%B8%80%E7%BB%84%EF%BC%89%E8%B5%9B%E5%90%8E%E6%80%9D%E8%80%83/","excerpt":"比赛链接东北林业大学第15届校赛（大一组）","text":"比赛链接东北林业大学第15届校赛（大一组） A.三角形面积(easy)123456789101112#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int main()&#123; double a,b,c,p; scanf(&quot;%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c); p=0.5*(a+b+c); printf(&quot;%.1lf\\n&quot;,sqrt(p*(p-a)*(p-b)*(p-c))); return 0;&#125; B.最大质因子(medium)123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;string.h&gt;int getprime(int n)&#123; int i=2; int res=1; while(n&gt;2) &#123; if(n%i==0) &#123; n/=i; res=i; &#125; else i++; &#125; return res;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d\\n&quot;,getprime(n)); return 0;&#125; C.杨辉三角(easy&amp;二维数组做法)1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int a[31][31]; memset(a,0,sizeof(a)); a[1][1]=1,a[2][1]=1,a[2][2]=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; if(j==1) a[i][j]=1; if(i&gt;2&amp;&amp;j&gt;1) a[i][j]=a[i-1][j]+a[i-1][j-1]; printf(&quot;%d &quot;,a[i][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; D.”nefu”的数目(medium)这题一开始没有看懂题目,其实只需要用暴力枚举n-e-f-u个数的方法就行了,好蠢··· 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int count=0; char a[55]; gets(a); int len=strlen(a); //开始枚举 for(int i=0;i&lt;len;i++) &#123; if(a[i]==&#x27;n&#x27;) &#123; for(int j=i+1;j&lt;len;j++) if(a[j]==&#x27;e&#x27;) &#123; for(int k=j+1;k&lt;len;k++) if(a[k]==&#x27;f&#x27;) &#123; for(int q=k+1;q&lt;len;q++) if(a[q]==&#x27;u&#x27;) count++;//计数 &#125; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,count);&#125; E.最小修改次数(difficult)滑动窗口算法实现 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;string.h&gt;int min(int a,int b)&#123; return a&lt;b?a:b;&#125;int main()&#123; int count=0; char a[1003],b[1003]; gets(a); gets(b); int l1=strlen(a); int l2=strlen(b); if(l1==l2) &#123; for(int i=0;i&lt;l1;i++) if(a[i]!=b[i]) count++; &#125; else &#123; count=10000; for(int i=0;i&lt;=l1-l2;i++) &#123; int k=0; for(int j=0;j&lt;l2;j++) //滑动窗口算法实现主体 &#123; if(a[j+i]!=b[j]) k++; &#125; count=min(k,count); &#125; &#125; printf(&quot;%d\\n&quot;,count); return 0;&#125; F.字典序(medium)主要是难想到8进制字典序的比较方法(按照八进制最大数来比较) 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int main()&#123; int n,a; scanf(&quot;%d&quot;,&amp;n); if(n/32767) printf(&quot;77777\\n&quot;); else &#123; if(n/32760) &#123;a=7777*10+n%32760;printf(&quot;%d\\n&quot;,a);&#125; else if(n/4095) printf(&quot;7777\\n&quot;); else &#123; if(n/4088) &#123;a=777*10+n%4088;printf(&quot;%d\\n&quot;,a);&#125; else if(n/511) printf(&quot;777\\n&quot;); else &#123; if(n/504) &#123;a=77*10+n%504;printf(&quot;%d\\n&quot;,a);&#125; else if(n/63) printf(&quot;77\\n&quot;); else &#123; if(n/56) &#123;a=7*10+n%56;printf(&quot;%d\\n&quot;,a);&#125; else if(n/7) printf(&quot;7\\n&quot;); else &#123; printf(&quot;%d\\n&quot;,n); &#125; &#125; &#125; &#125; &#125; return 0;&#125; G.最小差值(水题)一开始给这个图搞蒙了,以为是道难题,这题和新风杯2020级的求平衡位置那题一样 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;math.h&gt;typedef long long ll;ll a[200001];ll min(ll a,ll b)&#123; return a&lt;b?a:b;&#125;int main()&#123; ll n,sum1=0,sum2=0; scanf(&quot;%lld&quot;,&amp;n); for(ll i=0;i&lt;n;i++) &#123; scanf(&quot;%lld&quot;,a+i); sum2+=a[i]; &#125; ll k,minn=1e9; for(ll i=0;i&lt;n;i++) &#123; k=abs(sum2-sum1); minn=min(k,minn); sum1+=a[i]; sum2-=a[i]; &#125; printf(&quot;%lld\\n&quot;,minn); return 0;&#125; H.染色方案(difficult)这题我没想出来,所以就是difficult,还没有想出来,等学会深度搜索再回来看看 I.最大正方形(difficult)1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;void sort(int *a,int n)&#123; int t; for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) if(a[i]&gt;a[j]) &#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125;&#125;int main()&#123; int n,k; scanf(&quot;%d&quot;,&amp;n); int a[n]; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,a+i); for(int i=1;i&lt;=n;i++) &#123; k=0; for(int j=n-1;j&gt;=0;j--) &#123; if(a[j]&gt;=i) k++; &#125; if(k&gt;=i) continue; else &#123; k=i-1; break; &#125; &#125; printf(&quot;%d\\n&quot;,k); return 0;&#125; J.最大值(medium)这题我一直觉得我的做法没错但就是WA,其实是自己蠢了没有想到几个值相等且都是最大值的情况🤡 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;int a[200006];int max(int a,int b)&#123; return a&gt;b?a:b;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int maxxx=0; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,a+i); maxxx=max(maxxx,a[i]); &#125; int p=0,k; for(int i=0;i&lt;n;i++) &#123; if(maxxx==a[i]) &#123; p++; k=i; &#125; &#125; if(p==1) &#123; int maxxxx=0; for(int i=0;i&lt;n;i++) &#123; if(i==k) continue; maxxxx=max(maxxxx,a[i]); &#125; for(int i=0;i&lt;n;i++) &#123; if(i==k) &#123; printf(&quot;%d\\n&quot;,maxxxx); continue; &#125; printf(&quot;%d\\n&quot;,maxxx); &#125; &#125; else &#123; for(int i=0;i&lt;n;i++) printf(&quot;%d\\n&quot;,maxxx); &#125; return 0;&#125; K.循环排列(difficult)123456#include&lt;stdio.h&gt;int main()&#123;&#125; L.库特与围棋(difficult)12345678910111213141516#include&lt;stdio.h&gt;#include&lt;math.h&gt;typedef long long ll;int main()&#123; ll n; scanf(&quot;%lld&quot;,&amp;n); ll a=sqrt(n); ll ans=4*a; ll b=n-a*a; if(b==0) printf(&quot;%lld\\n&quot;,ans); else if(b&gt;0&amp;&amp;b&lt;=a) printf(&quot;%lld\\n&quot;,ans+2); else if(b&gt;a) printf(&quot;%lld\\n&quot;,ans+4); return 0;&#125; Thanks for NEFUOJ","categories":[],"tags":[{"name":"-Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"}]},{"title":"简便方法合集","slug":"2020-12-22-简便方法合集","date":"2020-12-21T16:00:00.000Z","updated":"2020-12-22T04:32:46.742Z","comments":true,"path":"2020/12/22/2020-12-22-简便方法合集/","link":"","permalink":"http://example.com/2020/12/22/2020-12-22-%E7%AE%80%E4%BE%BF%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/","excerpt":"有关因数与因子问题可参考[此博客]","text":"有关因数与因子问题可参考[此博客] 1.快速求因子个数12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;typedef long long ll;ll dcp(ll n)&#123; ll i,ans=1; for(i=2;i*i&lt;n;i++) &#123; if(n%i==0) &#123; ll temp=0; while(n%i==0) &#123; n/=i; temp++; &#125; ans*=(temp+1); &#125; &#125; if(n&gt;1) ans*=2; return ans;&#125;int main()&#123; ll x; scanf(&quot;%lld&quot;,&amp;x); /* ll count=0; while(x!=2) &#123; x=dcp(x); count++; &#125; printf(&quot;%lld\\n&quot;,count); 求迭代次数 */ printf(&quot;%lld\\n&quot;,dcp(x)); return 0;&#125; 2.快速求因数和1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int sum(int n)&#123; int s=1; for(int i=0;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; int a=1; while(n%i==0) &#123; n/=i; a*=i; &#125; s=s*(a*i-1)/(i-1); &#125; &#125; if(n&gt;1) s=s*(n+1); return s;&#125;int main()&#123; int x; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,sum(x)); return 0;&#125;","categories":[],"tags":[{"name":"-Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"}]},{"title":"回型矩阵","slug":"2020-12-21-回型矩阵","date":"2020-12-20T16:00:00.000Z","updated":"2021-01-07T05:39:26.955Z","comments":true,"path":"2020/12/21/2020-12-21-回型矩阵/","link":"","permalink":"http://example.com/2020/12/21/2020-12-21-%E5%9B%9E%E5%9E%8B%E7%9F%A9%E9%98%B5/","excerpt":"","text":"123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int x=1,y=0,cnt=0; int a[101][101]; memset(a,0,sizeof(a)); while(cnt&lt;n*n) //模拟画笔-上下左右 &#123; while(y+1&lt;=n&amp;&amp;!a[x][y+1]) a[x][++y]=++cnt; //右 while(x+1&lt;=n&amp;&amp;!a[x+1][y]) a[++x][y]=++cnt; //下 while(y-1&gt;=1&amp;&amp;!a[x][y-1]) a[x][--y]=++cnt; //左 while(x-1&gt;=1&amp;&amp;!a[x-1][y]) a[--x][y]=++cnt; //上 &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) printf(&quot;%d &quot;,a[i][j]); printf(&quot;\\n&quot;); &#125; return 0;&#125;","categories":[],"tags":[{"name":"-Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"}]},{"title":"编写头文件里的power函数,并优化(快速幂)","slug":"2020-12-19-快速幂(power)","date":"2020-12-19T16:00:00.000Z","updated":"2021-01-02T04:58:43.072Z","comments":true,"path":"2020/12/20/2020-12-19-快速幂(power)/","link":"","permalink":"http://example.com/2020/12/20/2020-12-19-%E5%BF%AB%E9%80%9F%E5%B9%82(power)/","excerpt":"#include&lt;math.h&gt;头文件里有power函数但是可能没有快速幂快，至于为什么要定义mod=1e9+7然后取余我也没太清楚，可能是数据结构？","text":"#include&lt;math.h&gt;头文件里有power函数但是可能没有快速幂快，至于为什么要定义mod=1e9+7然后取余我也没太清楚，可能是数据结构？ 1.最开始学C的时候写的平方求法(数据小的时候可以进行,数据大了时间会超时)1234567891011#include&lt;stdio.h&gt;int main()&#123; int a,b,sum=1; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); for(int i=1;i&lt;=b;i++) sum*=a; printf(&quot;%d\\n&quot;,sum); return 0;&#125; 2.快速幂(power)1234567891011121314151617181920212223#include&lt;stdio.h&gt;typedef long long ll;const ll mod=1e9+7;ll power(ll g,ll n)&#123; ll ans=1; while(n) //n是g的次方数 &#123; if(n&amp;1) ans=ans*g%mod; g=g*g%mod; n&gt;&gt;=1; //运用位运算将n缩小两倍 &#125; return ans;&#125;int main()&#123; ll n,g; scanf(&quot;%lld%lld&quot;,&amp;g,&amp;n); printf(&quot;%lld\\n&quot;,power(g,n)); return 0;&#125;","categories":[],"tags":[{"name":"-Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"}]},{"title":"Python初体验","slug":"2020-12-17-Python初体验","date":"2020-12-16T16:00:00.000Z","updated":"2021-01-09T06:28:16.608Z","comments":true,"path":"2020/12/17/2020-12-17-Python初体验/","link":"","permalink":"http://example.com/2020/12/17/2020-12-17-Python%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"1.类型 字符型 整数型 浮点数型 字符串型 布尔型 注：Python注重缩进","categories":[],"tags":[{"name":"-Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"指针编写函数invstr--字符串逆序存放输出","slug":"2020-12-17-指针编写字符串逆序存放输出","date":"2020-12-16T16:00:00.000Z","updated":"2020-12-17T08:23:19.579Z","comments":true,"path":"2020/12/17/2020-12-17-指针编写字符串逆序存放输出/","link":"","permalink":"http://example.com/2020/12/17/2020-12-17-%E6%8C%87%E9%92%88%E7%BC%96%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%86%E5%BA%8F%E5%AD%98%E6%94%BE%E8%BE%93%E5%87%BA/","excerpt":"","text":"12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt; //引入库函数void invstr(char *s) //定义倒序存放的函数&#123; char *p,t; int i,len=strlen(s); for(i=0,p=s;i&lt;len/2;i++) &#123; t=*(p+i); *(p+i)=*(p+len-i-1); //将数组的前一半与后一半对换 *(p+len-i-1)=t; &#125;&#125;int main()&#123; char a[10000]; gets(a); invstr(a); printf(&quot;%s&quot;,a); //输出倒序后的数组 return 0;&#125; 这是我用指针写的第一个函数,Keep Fighting.","categories":[],"tags":[{"name":"Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"}]},{"title":"排序算法合集","slug":"2020-12-17-排序算法合集","date":"2020-12-16T16:00:00.000Z","updated":"2021-01-14T05:10:42.808Z","comments":true,"path":"2020/12/17/2020-12-17-排序算法合集/","link":"","permalink":"http://example.com/2020/12/17/2020-12-17-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%88%E9%9B%86/","excerpt":"1.冒泡排序(BubbleSort)1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int *a,int *b)&#123; int temp; temp=*a; *a=*b; //编写交换值函数swap *b=temp;&#125;void BubbleSort(int a[],int n)&#123; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,a+i); for(int i=0;i&lt;n-1;i++) //冒泡排序主题 for(int j=i+1;j&lt;n;j++) if(a[i]&gt;a[j]) swap(&amp;a[i],&amp;a[j]);&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int a[n]; BubbleSort(a,n); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]); return 0;&#125;","text":"1.冒泡排序(BubbleSort)1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int *a,int *b)&#123; int temp; temp=*a; *a=*b; //编写交换值函数swap *b=temp;&#125;void BubbleSort(int a[],int n)&#123; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,a+i); for(int i=0;i&lt;n-1;i++) //冒泡排序主题 for(int j=i+1;j&lt;n;j++) if(a[i]&gt;a[j]) swap(&amp;a[i],&amp;a[j]);&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int a[n]; BubbleSort(a,n); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]); return 0;&#125; 2.选择排序(SelectSort)123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;void swap(int *a,int *b)&#123; int temp; temp=*a; *a=*b; //编写交换值函数swap *b=temp;&#125;void SelectSort(int a[],int n)&#123; for(int i=0;i&lt;n-1;i++) &#123; int minIndex=i; for(int j=i+1;j&lt;n;j++) &#123; if(a[j]&lt;a[minIndex]) minIndex=j; &#125; swap(&amp;a[i],&amp;a[minIndex]); &#125;&#125;int main()&#123; int a[10000],n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,a+i); SelectSort(a,n); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]); return 0;&#125; 3.插入排序(InsertSort)12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;void swap(int *a,int *b)&#123; int temp; //定义中间变量 temp=*a; *a=*b; *b=temp;&#125;void InsertSort(int a[],int n)&#123; int i,j,temp; for(i=1;i&lt;n;i++) &#123; temp=a[i]; for(j=i-1;j&gt;=0&amp;&amp;a[j]&gt;temp;j--) //如果条件成立就将数组前移 a[j+1]=a[j]; a[j+1]=temp; //条件不成立or循环结束将temp值放在j+1处 &#125;&#125;int main()&#123; int a[10000],n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,a+i); InsertSort(a,n); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]); return 0;&#125; 4.快速排序(QuickSort)1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;void swap(int *a,int *b)&#123; int temp; //定义中间变量 temp=*a; *a=*b; *b=temp;&#125;void QuickSort(int a[],int left,int right)&#123; if(left&gt;=right) return; int k=a[left]; //排序从左边开始比较 int i=left,j=right; while(i!=j) &#123; while(j&gt;i&amp;&amp;a[j]&gt;=k) j--; swap(&amp;a[i],&amp;a[j]); while(i&lt;j&amp;&amp;a[i]&lt;=k) i++; swap(&amp;a[i],&amp;a[j]); &#125; QuickSort(a,left,i-1); QuickSort(a,i+1,right);&#125;int main()&#123; int a[10000],n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,a+i); QuickSort(a,0,n-1); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]); return 0;&#125; 5.归并排序(MergeSort)12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;int a[10000],b[10000];void swap(int *a,int *b)&#123; int temp; temp=*a; *a=*b; *b=temp;&#125;void Merge(int a[],int left,int mid,int right,int tmp[])&#123; int pb=0,p1=left,p2=mid+1; while(p1&lt;=mid&amp;&amp;p2&lt;=right) &#123; if(a[p1]&lt;a[p2]) tmp[pb++]=a[p1++]; //归并排序的主体部分,将二分部分进行排序 else tmp[pb++]=a[p2++]; &#125; while(p1&lt;=mid) tmp[pb++]=a[p1++]; while(p2&lt;=right) tmp[pb++]=a[p2++]; for(int i=0;i&lt;right-left+1;i++) a[left+i]=tmp[i]; //a数组下标从left+i开始&#125;void MergeSort(int a[],int left,int right,int tmp[])&#123; if(right&gt;left) //二分数组进行排序 &#123; int mid=left+(right-left)/2; MergeSort(a,left,mid,tmp); MergeSort(a,mid+1,right,tmp); Merge(a,left,mid,right,tmp); &#125;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,a+i); MergeSort(a,0,n-1,b); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]); return 0;&#125;","categories":[],"tags":[{"name":"Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"}]},{"title":"汇编语言","slug":"2020-12-17-汇编语言","date":"2020-12-16T16:00:00.000Z","updated":"2021-01-26T04:04:30.359Z","comments":true,"path":"2020/12/17/2020-12-17-汇编语言/","link":"","permalink":"http://example.com/2020/12/17/2020-12-17-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"Flag：15天学完汇编！！🤡（已经学完但是后续不懂得还要来回顾，有些地方没有太过深入！）还配置了notepad++和dosbox一键编译运行好舒服！！！","text":"Flag：15天学完汇编！！🤡（已经学完但是后续不懂得还要来回顾，有些地方没有太过深入！）还配置了notepad++和dosbox一键编译运行好舒服！！！ 1.总线说明123456781）地址总线 ;若地址总线有N根地址总线，也可以说地址总线宽度炜N就可以寻找2^N的内存单元2）数据总线 ;进行CPU与内存或其他器件之间数据传输，它的宽度决定了数据传输的速度3）控制总线 ;控制总线多少决定控制的数量注：1）汇编指令是机器指令的助记符，同机器指令一一对应2）每一种CPU都有自己的汇编指令集3）CPU可以直接使用的信息在存储器中存放4）在存储器中指令和数据没有任何区别，都是二进制信息 12345678910111213assume cs:codesg ;伪指令codesg segmentmov ax,0123hmov bx,0456hadd ax,bx ;现在还只能写出十六进制的加法add ax,axmov ax,4c00hint 21hcodesg endsend 2.寄存器12348086的14个寄存器AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW 以上都是16位,可以存放两个字节AX,BX,CX,DXT通常被用来存放一般性数据被称为通用寄存器AX可以分为AH和AL即High(前八)和Low(后八)位,且相互独立,BX,CX,DX同理 注：1Byte=8bit,1Kb=1024B,1Mb=1024Kb,1Gb=1024Kb,1Tb=1024Gb; 3.[BX]和loop(循环)12345[bx]bx里存放的是偏移地址段地址为ds中的内容即地址为ds*16+bx在对bx里传入数据时不能直接传入地址,必须将地址给bx然后再mov ax,[bx]即可偏移地址EA和段地址SA,指向（EA*16+SA）;inc为自增,mov为赋值,sub为减法,add为加法,push为出栈,pop为入栈cx里默认存放loop循环次数,并且loop所标识的标号要在loop的前面 123456789101112131415;例子1：求2^12用loopassume cs:codecode segmentstart: mov ax,2 mov cx,11s: add ax,ax loop s mov ax,4c00H int 21Hcode endsend start 1234567891011121314;例子2：计算123*236的值loop（注意：数值不加H表示十进制）（加快速度可以将ax与cx值交换）assume cs:codecode segmentstart: mov ax,0 mov cx,236 s: add ax,123 loop s mov ax,4c00h int 21hcode endsend start 1234567891011121314151617181920212223;例子3：计算ffff:0~ffff:b单元中数据的和，结果储存在dx中assume cs:codecode segmentstart: mov ax,0ffffh ;对寄存器进行写入时数据开头不能为字母不然会出错此时要开头处加0 mov ds,ax ;对ds进行写入时不能直接写入 mov bx,0 mov dx,0 mov cx,12 s: mov al,[bx] mov ah,0 add dx,ax inc bx ;bx自增1,使得指向下一单元 loop s mov ax,4c00h int 21hcode endsend start 1234567891011121314151617181920;例子4:将ffff:0~ffff:b段中单元中的数据拷贝到0:200~0:20b单元中assume cs:codecode segmentstart: mov cx,12 ;设置循环次数 mov bx,0 ;清楚寄存器内容s: mov ax,0ffffh mov ds,ax ;设置指向ds*16+bx mov dl,[bx] mov ax,0020h mov ds,ax mov [bx],dl inc bx ;bx自增1 loop s mov ax,4c00h int 21hcode endsend start 1234567891011121314151617181920;例题4的改进方法,循环连续改变ds会消耗时间,可用es来保存另一个指向地址assume cs:codecode segmentstart: mov ax,0ffffh mov ds,ax mov ax,0020h mov es,ax mov bx,0 mov cx,12s: mov dl,[bx] mov es:[bx],dl inc bx loop s mov ax,4c00h int 21hcode endsend start 4.包含多个段的程序(code-ss代码段data-ds数据段stack-ss栈段)12345678910111213141516;dw即define word就是定义字型数据每个字型数据占用两个字节即16bits,并且定义时默认从CS:0开始定义;例:累加八个数据assume cs:codecode segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hstart: mov ax,0 mov bx,0 mov cx,8 s: add ax,cs:[bx] add bx,2 loop s mov ax,4c00h int 21hcode endsend start 123456789101112131415161718192021222324252627282930313233assuem cs:code,ds:data,ss:stackdata segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdata endsstack segment dw 0,0,0,0,0,0,0,0stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax mov bx,0 mov cx,8 s: push [bx] add bx,2 loop s mov bx,0 mov cx,8 s0: pop [bx] add bx,2 loop s0;没写完 mov ax,4c00h int 21hcode endsend start 5.更灵活的定位内存地址的方法1234567;and和or指令就是位运算中的&amp;和|运算即与非运算;ASCII已经学过所以直接略过，汇编语言中也可用ASCII数值(十六进制)来代替字符;此处还要说明一下dw与db还有dd的关系#dw：定义字类型变量，一个字数据占两个单元，读完一个，偏移量加2#db：定义字节类型变量，一个字节数据占一个单元，读完一个，偏移量加1#dd：定义双字类型变量，一个双字数据占据四个单元，读完一个，偏移量加4#上述偏移量也就是bx的步长，并且1字&#x3D;2字节&#x3D;16bits 123456789101112131415161718192021222324252627282930313233343536;例子：编写汇编语言实现英文的大小写转换assume cs:code,ds:datadata segment db &#39;BaSiC&#39; ;定义字节型数据 db &#39;iNfOrMaTiOn&#39;data endscode segmentstart: mov ax,data mov ds,ax mov bx,0 mov cx,5 ;第一个单词长度为5所以要循环五次 s: mov al,[bx] and al,11011111B ;通过&amp;运算使得小写字母ASCII值减小20H从而转换为大写 mov [bx],al inc bx ;步长+1 loop s mov bx,5 mov cx,11 s0: mov al,[bx] or al,00100000B ;与s循环同理,|运算不同,使大写字母ASCII值增加20H转化为小写字母 mov [bx],al inc bx loop s0 mov ax,4c00h int 21hcode endsend start [bx+idata]的用法1234567891011121314151617181920212223242526272829303132;mov ax,[bx+200]的多种写法;下列写法都与上式相同;mov ax,200[bx];mov ax,[200+bx];mov ax,[bx].200;例：利用[bx+idata]的方式使用数组进行大小写转换assume cs:code,ds:datadata segment db &#39;BaSiC&#39; db &#39;MinIX&#39;data endscode segemntstart: mov ax,data mov ds,ax mov bx,0 mov cx,5 s: mov al,[bx] and al,11011111b mov [bx],al mov al,[bx+5] or al,00100000b mov [bx+5],ax inc bx loop s mov ax,4c00h int 21hcode endsend start 5.2 SI和DI123;SI和DI也是和bx功能相近的寄存器,但是他们不能够分成两个8位寄存器来使用;[bx+si+idata]的不同写法([bx+di+idata]与之相同);1)[bx+idata+si] 2)[idata+bx+si] 3)idata[bx][si] 4)[bx].idata[si] 5)[bx][si].idata 5.3 不同寻址方式的灵活运用12345678910111213141516171819202122232425262728293031323334353637383940414243;可以用dx来临时保存cx中的数值;如果dx也被使用,且程序中经常需要进行数据的暂存,可以将寄存器中的数据存放在内存中,但是却有些麻烦;最后优化可以使用栈来实现cx的存放和使用assume cs:code,ds:data,ss:stackdata segment db &#39;ibm &#39; db &#39;dec &#39; db &#39;dos &#39; db &#39;vax &#39;data endsstack segment dw 0,0,0,0,0,0,0,0stack endscode segmentstart: mov ax,data mov ds,ax mov bx,0 mov cx,4 s0: push cx ;即为mov dx,cx mov si,0 mov cx,3 s: mov al,[bx+si] and al,11011111b mov [bx+si],al int si loop s add bx,16 pop cx ;即为mov cx,dx loop s0 mov ax,4c00h int 21h code endsend start 6.数据处理的两个基本问题1234567891011121314151617;reg用来表示寄存器,sreg来表示段寄存器;reg包括ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di;sreg包括ds,ss,cs,es;8086中只有bx,si,di,bp来储存内存单元的地址;bx不能和bp同时调用即[bx+bp]和[si+di]是错误的用法;sp和bp默认段地址在ss中,bx默认段地址在ds中;si和di可以都被bp,bx调用;绝大部分机器指令都是进行数据处理的指令,可以分为三类:1）读取 2）写入 3）运算;SA(Segment Address)段地址EA(Effective Address)偏移地址 立即数(idata);在没有寄存器名存在情况下,用操作符X ptr指明内存单元的长度,X在汇编指令中可以为word或byte;mov word ptr ds:[0],1 &#x2F;&#x2F;将0001送入内存单元;inc word ptr [bx] &#x2F;&#x2F;将两个内存单元合并的地址自增1;inc word ptr ds;[0] &#x2F;&#x2F;将ds:[0]的字型数据自增1;add word ptr [bx],2 &#x2F;&#x2F;将ds:bx指向的字型数据加2;在没有寄存器参与的内存单元访问指令中,用word&#x2F;byte ptr显性指明访问的内存单元长度是很有必要的;push指令只进行字(2个内存单元即2个字节)操作;一般来说,用[bx+idata+si]的方式来访问结构体中的数据,bx定位整个结构体,idata定位结构体中的某一个数据项,si定位数组项中的每个元素也有另外的写法[bx].idata和[bx].idata[si] 6.1 div(division)指令12;div的除数有8位和16位两种,放在一个reg和内存单元中;div的被除数默认放在AD或(DX和AX)中,如果除数为8位,则被除数为16位,默认在AX中存放,如果除数为16位,则被除数默认在DX和AX中一起存放,并且DX存放高16位,AX存放低16位 12345;高位地方存放余数,低位存放商;div byte ptr ds:[0] &#x2F;&#x2F;(al)&#x3D;(ax)&#x2F;((ds)*16+0)的商,(ah)&#x3D;((ds)*16+0)的余数;div word ptr es:[0] &#x2F;&#x2F;(ax)&#x3D;[(dx)*10000h+(ax)]&#x2F;((es*16)+0)的商,(dx)&#x3D;[(dx)*10000h+(ax)]&#x2F;((es*16)+0)的余数;div byte ptr [bx+si+8] &#x2F;&#x2F;(ax)&#x3D;(ax)&#x2F;((ds)*16+(bx)+(si)+8)的商,(dx)&#x3D;(ax)&#x2F;((ds)*16+(bx)+(si)+8)的余数;div word ptr [bx+si+8] &#x2F;&#x2F;(ax)&#x3D;[(dx)*10000h+(ax)]&#x2F;((ds)*16+(bx)+(si)+8)的商,(dx)&#x3D;([(dx)*10000h+(ax)])&#x2F;((ds)*16+(bx)+(si)+8)的余数 1234567891011121314;例：利用div除法指令计算100001&#x2F;100,100001&gt;65535所以要用AX+DX一起存放被除数assume cs:codecode segmentstart: mov dx,1 mov ax,86a1h mov bx,100 div bx mov ax,4c00h int 21hcode endsend start;运行结果(dx)&#x3D;0001余数(ax)&#x3D;03e8h商 123456789101112;例：利用div除法指令计算1001&#x2F;100,1001&lt;65535所以只需要用AX来存放被除数assume cs:codecode segmentstart: mov ax,1001 mov bl,100 ;被除数&lt;65535时,除数用8位寄存器来存放 div bl mov ax,4c00h int 21hcode endsend start 123456789101112131415161718192021;例：利用dd指令存放数据并计算100001&#x2F;100assume cs:code,ds:datadata segemnt dd 100001 dw 100 dw 0data endscode segmentstart: mov ax,data mov ds,ax mov ax,ds:[0] mov dx,ds:[2] div word ptr ds:[4] mov ds:[6],ax mov ax,4c00h int 21hcode endsend start 6.2 dup的用法1234;db 3 dup(0)--定义了3个字节型数据,并且它们的值都是0,相当于db 0,0,0;db 3 dup(0,1,2)--定义了9个字节型数据,并且它们的值是0,1,2,0,1,2,0,1,2,相当于db 0,1,2,0,1,2,0,1,2;db 3 dup(&#39;abc&#39;,&#39;ABC&#39;)--定义了6个字节型数据,它们是&#39;abcABCabcABCabcABC&#39;,相当于db &#39;abcABCabcABCabcABC&#39;;dup一般使用格式:db&#x2F;dw&#x2F;dd 重复的次数 dup(重复的数据) 12345678910111213141516171819;实验七assume cs:codesg,ds:data,es:tabledata segment db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39; db &#39;1984&#39;,&#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39; db &#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39; ;以上是表示21年的21个字符串 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ;以上是表示21年公司总收入的21个dword型数据 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 ;以上是表示21年公司雇佣人员人数的21个word型数据data endstable segment db 21 dup(&#39;year summ ne ??&#39;)table ends 7.转移指令的原理1234567891011;offset xxx就是取得xxx的偏移地址;jmp为无条件转移,可以只修改IP,也可以同时修改CS和IP;jmp short 标号(转到标号处执行指令),这种指令实现的是段内&#39;短&#39;转移,它对IP的修改范围是-128~127,所以它向前转移可以越过128个字节,向后转移可以越过127个字节,short指明此处可以转移的最大距离为128(也就是8位位移),8位位移由编译程序在编译时算出;jmp near ptr 标号可以实现16位转移(-32768~32767),和jmp short 标号指令一样16位位移由编译程序在编译时算出;jmp far ptr 标号实现的是段间转移,是远转移,与上面两种不同的是这种方式,同时对cs和ip进行跳转,所以可以不用像上面两种那样位移要通过编译程序在编译时算出,它对应的机器码包含了转移的地址;jmp dword ptr 标号实现的是段间转移;例：jmp dword ptr标号的作用示范mov ax,0123hmov ds:[0],ax ;低位存放转移目的的偏移地址0123hmov word ptr ds:[2],0 ;高位存放转移目的的段地址0000jmp dword ptr ds:[0] ;jmp跳转到(cs:[2]):(cs:[0])的地方也就是0000:0123h 123456789101112131415161718192021;jcxz指令是有条件转移指令,并且所有的有条件的转移指令都是短转移;格式：jcxz 标号(如果cx为0则转移到标号处执行);例子：课本利用jcxz补全程序(在2000h段中找到第一个值为0的字节,找到后将他的偏移地址存放在dx中);loop指令相当于(cx)--;if((cx)!&#x3D;0) jmp short 标号;nop就是nope也就是不做任何处理assume cs:codecode segmentstart: mov ax,2000h mov ds,ax mov bx,0 s: mov ch,0 mov cl,[bx] jcxz ok inc bx jmp short s ok: mov ds,bx mov ax,4c00h int 21hcode endsend start 8.Call和ret指令12345;call和ret指令都是转移指令,他们都修改IP，或同时修改CS和IP;ret 等价于 pop ip 就是将现在栈中指向的字单元赋值给ip;retf等价于 先pop ip 然后再pop cs出栈;&quot;call+标号&quot;指令是先将此时的ip入栈然后进行转移转移方式和jmp一样转到标号地址进行等价于push ip+jmp near ptr 标号;call far ptr 标号和retf差不多先将cs压入栈中然后将ip压入栈中并且此处的cs和ip是标号处的段地址和偏移地址相当于","categories":[],"tags":[{"name":"-Assembly language","slug":"Assembly-language","permalink":"http://example.com/tags/Assembly-language/"}]},{"title":"WangJp_'s Somethings","slug":"About Tyl&WJP","date":"2020-12-16T16:00:00.000Z","updated":"2020-12-17T11:24:18.606Z","comments":true,"path":"2020/12/17/About Tyl&WJP/","link":"","permalink":"http://example.com/2020/12/17/About%20Tyl&WJP/","excerpt":"This is my Qzone.This is my CSDN.","text":"This is my Qzone.This is my CSDN. He is my idol Alan Mathison Turing.123456#include&lt;stdio.h&gt;int main()&#123; printf(&quot;Welcome To My Github Blog\\n&quot;); return 0;&#125;","categories":[],"tags":[{"name":"Welcome Everybody","slug":"Welcome-Everybody","permalink":"http://example.com/tags/Welcome-Everybody/"}]}],"categories":[],"tags":[{"name":"-Daile Life","slug":"Daile-Life","permalink":"http://example.com/tags/Daile-Life/"},{"name":"-Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"},{"name":"-Network Security","slug":"Network-Security","permalink":"http://example.com/tags/Network-Security/"},{"name":"-Course Learning","slug":"Course-Learning","permalink":"http://example.com/tags/Course-Learning/"},{"name":"-Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Programming-ACS","slug":"Programming-ACS","permalink":"http://example.com/tags/Programming-ACS/"},{"name":"-Assembly language","slug":"Assembly-language","permalink":"http://example.com/tags/Assembly-language/"},{"name":"Welcome Everybody","slug":"Welcome-Everybody","permalink":"http://example.com/tags/Welcome-Everybody/"}]}